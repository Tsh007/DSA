//////
//////  5_maximum_sum_of_non_adjacent_elements.cpp
//////  combinedDsa
//////
//////  Created by Tejash Singh on 20/10/24.
//////
////
////#include <stdio.h>
////
////#include "bits/stdc++.h"
////
////using namespace std;
////
////////recursion
//////int customFunc(vector<int>&nums,int n,int sum){
//////    
//////    if(n+2>=nums.size())return sum;
//////        
//////    int maxSum = INT_MIN;
//////    
//////    for(int i = n+2 ;i<nums.size();i++){
//////        int val = customFunc(nums, i, nums[i]);
//////        maxSum = max(val,maxSum);
//////    }
//////    
//////    return maxSum+sum;
//////}
//////
//////int rob(vector<int>& nums) {
//////    
//////    return customFunc(nums,-2,0);
//////
//////}
////
////
////////recursion + memoisation == top down approach
//////int customFunc(vector<int>&nums,int n,int sum,vector<int>&dp){
//////    
//////    if(n+2>=nums.size())return sum;
//////        
//////    if(dp[n+2]!=-1)return dp[n+2];
//////    int maxSum = INT_MIN;
//////    
//////    for(int i = n+2 ;i<nums.size();i++){
//////        int val = customFunc(nums, i, nums[i],dp);
//////        maxSum = max(val,maxSum);
//////    }
//////    
//////    return dp[n+2] = maxSum+sum;
//////}
//////
//////int rob(vector<int>& nums) {
//////    
//////    vector<int>dp(nums.size()+1,-1);
//////    
//////    return customFunc(nums,-2,0,dp);
//////    
//////}
////
////
//////tabulation == iterative + memoise
////int rob(vector<int>& nums) {
////    
////    vector<int>dp(nums.size()+1,0);
////    
//////    if(n+2>=nums.size())return sum;
////        
////    int maximumSum = INT_MIN;
////    dp[nums.size()-1] = nums[nums.size()-1];
////    
////    dp[nums.size()-2] = nums[nums.size()-2];
////    
////    maximumSum = max(dp[nums.size()-1],dp[nums.size()-2]);
////    
////    for(int k = int(nums.size()) - 3;k>=0;k--){
////        int maxSum = INT_MIN;
////        
////        if(k+2 >= nums.size())continue;
////        
////        for(int i = k+2 ;i<nums.size();i++){
////            int val = dp[i];
////            maxSum = max(val,maxSum);
////        }
////        
////        dp[k] = maxSum+nums[k];
////        maximumSum = max(maximumSum,dp[k]);
////        
//////        cout<<dp[k+2]<<endl;
////    }
//////    for(auto i : dp){
//////        cout<<i<<" ";
//////    }
////    return maximumSum;
////}
////
////
////
//////space optimzation
////
////
////
////int main(){
////
////    //vimp to remember
////    //vector.size() returns unsigned long int
////    vector<int> nums = {1,2,3,1};
//////    nums = {1,2,3,4};//6
//////    nums = {2,7,9,3,1};//12
////    
//////    nums = {1,400,29,48,399};
//////    nums = {6,6,4,8,4,3,3,10};
////    
////    cout<<rob(nums)<<endl;
////    
//////    cout<<type(nums.size());
//////    if(-1<int(nums.size()))cout<<1;
//////    else{
//////        cout<<0;
//////    }
////    
////    
////    return 0;
////}
//
//
//
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////striver approach
//
//#include <stdio.h>
//#include "bits/stdc++.h"
//
//using namespace std;
//
//
////only recursion
////int customFunc(vector<int>&nums,int idx){
////    
////    if(idx == 0)return nums[0];
////    if(idx < 0)return 0;
////        
////    int pick = nums[idx] + customFunc(nums, idx-2);
////    
////    int notPick = 0 + customFunc(nums, idx-1);
////    
////    return max(pick,notPick);
////    
////}
////
////int rob(vector<int> &nums){
////    
////    return customFunc(nums, nums.size());
////    
////}
//
//
////recursion + memoisation = top down
////int customFunc(vector<int>&nums,int idx,vector<int>&dp){
////
////    if(idx == 0)return nums[0];
////    if(idx < 0)return 0;
////    
////    if(dp[idx] != -1)return dp[idx];
////
////    int pick = nums[idx] + customFunc(nums, idx-2,dp);
////
////    int notPick = 0 + customFunc(nums, idx-1,dp);
////
////    return dp[idx] = max(pick,notPick);
////
////}
////
////int rob(vector<int> &nums){
////    
////    vector<int>dp(nums.size(),-1);
////
////    return customFunc(nums, nums.size()-1,dp);
////
////}
//
//
//
////tabulation == bottomup == iterative + memoisation
//
////int rob(vector<int> &nums){
////
////    vector<int>dp(nums.size(),-1);
////
////    dp[0] = nums[0];
////    int negative = 0;
////        
////    for(int i = 1;i<nums.size();i++){
////        
//////        int pick = nums[i] + dp[i-2];
////        int pick = nums[i];
////        if(i>1)pick+=dp[i-2];
////        
////        int notPick = dp[i-1];
////        
////        dp[i] = max(pick,notPick);
////    }
////    
////    return dp[nums.size()-1];
////
////}
//
//
//
//
////space optimzation
//int rob(vector<int> &nums){
//
////    vector<int>dp(nums.size(),-1);
//
//    int prev = nums[0];
//    int prev2 = 0;
//
//    for(int i = 1;i<nums.size();i++){
//
////        int pick = nums[i] + dp[i-2];
//        int pick = nums[i];
//        if(i>1)pick+=prev2;
//
//        int notPick = prev;
//
//        int curr = max(pick,notPick);
//        
//        prev2 = prev;
//        prev = curr;
//    }
//
//    return prev;
//
//}
//
//
//
//int main(){
//    
//    vector<int> nums = {1,2,3,1};
//        nums = {1,2,3,4};//6
//        nums = {2,7,9,3,1};//12
//    
//        nums = {1,400,29,48,399};
//        nums = {6,6,4,8,4,3,3,10};
//    
//    cout<<rob(nums)<<endl;
//    
//    return 0;
//}
